// Pass One
Set symTable is a map <string, int>;
Set line_number <- 1;
Set loc <- 0;
Set has_error <- false;
// Pass Two
Set instruction is a string vector;
Set m_record is a int vector;
Set obj_program is a string vector;

// Split and Handle Addressing Mode
compile(input, line_number) Do
	Set flag <- 0 // Meet Char?
	Set count <- 0
	Set tmp <- ""
	Set instruction is a string vector

	For i: 0 to length of input Do
		// Ignore Comment and Line Break
		If input[i] is "." or "\n" or "\r" Do
		{
			If flag is 1 Do // perious has a Char
				push tmp to instruction
				tmp <- ""
				flag <- 0
			End If
			Break
		}
		// Ignore Witespace
		Else If input[i] is " " or "\t" then
		{
			If flag is 1 Do // perious has a Char
				push tmp to instruction
				tmp <- ""
				flag <- 0
			End If
			Continue
		}
		// Store Char
		Else then
		{
			If flag is 0 Do // perious has no Char
				count <- count + 1
			end If

			flag <- 1
			tmp <- tmp + input[i]
		}
		End If
	End For

	// Store Last Word
	if flag is 1 Do
		push tmp to instruction;
	End If

	// Statement
	Set statement is a map <string, string>
	Set label is a pointer point to statement["Label"]
	Set mnemoic is a pointer point to statement["Mnemoic"]
	Set operand is a pointer point to statement["Operand"]
	Set addressing is a pointer point to statement["Addressing"]

	If instruction size > 0 Do
		// No label
		If (first of instruction is not "END" or cannot find opcode) Do
			Insert "***" to the head of instruction
		End If
		// Assign Label, Mnemoic, Operand
		For i: 0 to instruction size Do
			Switch(i) Do
				case 0:
					If instruction[i] is not "***"
						Set label <- instruction[i]
					break
				case 1:
					Set mnemoic <- instruction[i]
					break
				case 2:
					Set operand <- instruction[i]
					break
				default:
					break
			End Switch
		End For
	End If

	// Check Operand, Addressing mode
	If instruction size > 5 Do
		// BYTE C content has space char
		If (mnemoic is "BYTE" and first character of operand is "C") Do
			Set operand <- operand + instruction[3] // first ' 
			// remaining content
			operand append remaining content and whitespaces
			Set addressing <- "Direct"
		Else then
			Throw error message
		End If
	Else If instruction size > 3
		
	End If
End Compile

CompileOne() Do
	Set is_start <- false
	Set input_line is a STRING
	Set line_number <- 1
	Set loc <- 0
	Set symTable is a map
	Set error_log is a map

	While has input Do
		Set input_line <- input
		Print line_number: input_line
		// START
		If find "START" in input_line Do
			Set is_start <- true
		End If

		// Compile and ignore empty line
		If is_start and length of input_line > 1 Do
			// [ Label, Mnemoic, Operand ]
			Set statement <- Compile(input_line, line_number)
			// Output Line NUmber and Loc
			Print "line_number: " statement["line_number"]
			Print "loc: " loc // hex number
			// END Program
			If statement["Label"] is "END" Do
			{
				Set is_start <- false
				Print "End of program."
				Break
			}
			// START from this line
			Else If statement["Mnemoic"] is "START" then
			{
				// Convert hex string to int, Set start position
				Set loc <- statement["Operand"]
				Print "Program name is " statement["Label"] .
				Print "Start from " statement["Operand"] .
			}
			// RESB
			Else If statement["Mnemoic"] is "RESB" then
			{
				Print "RESB is pesuDo instruction code."
				Set data_name <- statement["Label"]
				// Store data to Symbol Table If need
				store_sym() // FIXME
				Set byte <- statement["Operand"]
				Set loc <- loc + byte
			}
			// RESW
			Else If statement["Mnemoic"] is "RESW" then
			{
				Print "RESW is pesuDo instruction code."
				// Store data to Symbol Table If need
				store_sym() // FIXME
				Set word <- statement["Operand"]
				Set loc <- loc + word*3
			}
			// Other
			Else then
			{
				// Output Addressing Mode
				If statement["Addressing"] NOT empty then
				{
					Print "Addressing: " statement["Addressing"]
				}
				// Output Label, Mnemoic, Operand
				If NOT
					(statement["Label"] is empty and
					statement["Mnemoic"] is empty and
					statement["Operand"] is empty)
				 Do
				{
					Print "Label: " statement["Label"]
					Print "Mnemoic: " statement["Mnemoic"]
					Print "Operand: " statement["Operand"]
					// Store data to Symbol Table if need
					store_sym() // FIXME
					Set loc <- loc + 3
				}
				End If
			}
			end If
		End If

		Set line_number <- line_number + 1
	End While



	// Output Error Log
	Print "Error log:"
	Set iter_e <- begin of error_log
	While iter_e NOT the _end of error_log Do
		Print data_name of error_log[iter_e]
		Print loc of error_log[iter_e]
		iter_e <- iter_e + 1
	End While

	Return

End CompileOne

PassOne() Do
	Open middle_file
	string line

	While (Input) Do
		getline(Input, line)
		transform line to uppercase

		If (length of line  > 1) Do
			CompileOne(line)
		End If

		Set line_number <- line_number + 1
	End While

	Close middle_file
End PassOne

PassTwo() Do
	open middle_file
	string input
	int instruction_len;
	line_number <- 1;

	Read Middle File, split with '\t'

	Set instruction_len <- instruction size
	CompileTwo(instruction_len)

	If (instruction[2] is not "START") Do
		Print err_message: "Not starting at START."
		End If
		
		If (instruction[instruction_len - 4] is not "START") Do
		Print err_message: "Not ending at END."
	End If
End PassTwo

Main() Do
	PassOne()
	Output Symbol Table

	open middle_file

	If has_error Do
		Output middle_file
		Return 1
	End If

	PassTwo()
	If has_error Do
		Return 1
	End If

	Return 0
End Main

// Middle File: source code line number